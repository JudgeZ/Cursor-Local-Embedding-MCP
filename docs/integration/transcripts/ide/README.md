# IDE Transcript Catalog

This catalog tracks the golden interaction transcripts that back the integration
documentation, client scripts, and CI coverage described in the rest of the
repository. Every subdirectory corresponds to a supported IDE integration and
contains the canonical exchanges captured while replaying the client fixtures
against the Cursor Local Embedding MCP server. Transcripts are normalized with
[`scripts/transcripts/normalize.py`](../../../scripts/transcripts/normalize.py)
so the envelopes remain deterministic across platforms.

## Directory Layout

```
ide/
  README.md
  cursor/
    README.md
    <transcripts>
  windsurf/
    README.md
    <transcripts>
  vscode/
    README.md
    <transcripts>
```

Add additional IDE directories as support expands. Keep directory names
lowercase and hyphenate multiword IDE names (e.g., `jetbrains-gateway`).

## Naming Conventions

* Store golden transcripts as prettified JSON with deterministic key ordering.
* Use lowercase filenames with hyphens to separate transport scenarios:
  `stdio-noise.json`, `http-tls.json`, `wsl-bridge.json`, etc.
* Include transport modifiers immediately after the base protocol. Examples:
  `websocket-noise.json`, `http-tls-mutual.json`.
* Keep timestamps ISO-8601 formatted and in UTC.
* When a transcript includes multiple exchanges, encode them as an array of
  envelopes (`[{"jsonrpc": ...}, ...]`).

## Compression Policy

* Commit readable `.json` files for every transcript so that docs and code
  reviews can diff them easily.
* For transcripts larger than 256 KiB, add a companion `.json.zst` file
  compressed with `zstd -19`. These compressed copies allow CI runs to download
  the fixtures quickly without bloating the repository.
* Do **not** remove the human-readable `.json` files even when the compressed
  variant is present.

## Checksum Policy

* Maintain a `CHECKSUMS.sha256` file in each IDE directory listing checksums for
  both the `.json` and `.json.zst` copies (when present).
* Regenerate the checksum file with `sha256sum *.json *.json.zst > CHECKSUMS.sha256`
  whenever transcripts change.
* CI jobs must validate these checksums before replaying transcripts to guarantee
  that the fixtures have not drifted.

## Regeneration Workflow (Pending Client Automation)

Regenerate transcripts by replaying the client automation for each supported
transport and then normalizing the capture with the transcript tooling:

1. Run the language client helper with the desired IDE + transport pairing. For
   example:

   ```bash
   python clients/python/client.py \
     --ide cursor \
     --transport stdio-noise \
     --prompt "Summarize transcript capture." \
     --record-transcript tmp/cursor-stdio-noise.raw.json
   ```

2. Canonicalize the capture:

   ```bash
   python scripts/transcripts/normalize.py \
     tmp/cursor-stdio-noise.raw.json \
     --output docs/integration/transcripts/ide/cursor/stdio-noise.json
   ```

3. Regenerate checksums from the IDE directory:

   ```bash
   (cd docs/integration/transcripts/ide/cursor && sha256sum *.json > CHECKSUMS.sha256)
   ```

4. Commit both the normalized JSON files and refreshed checksum manifest. Add a
   `.json.zst` copy if the transcript exceeds 256 KiB (see compression policy).

Document any deviations or tooling flags in the subdirectory README so that
future contributors can reproduce the captures precisely. CI workflows consume
these normalized artifacts directly, so rerun the normalization script whenever
the raw captures change.

## Roadmap-Aligned Placeholder Fixtures

The [client implementation roadmap](../../integration/client-plan.md) enumerates
the request/response pairs every language client must exercise across the
`stdio`, `http`, and `tls` transports. Placeholder exchanges are generated by
the "Regenerate Fixture Corpus" GitHub Action and published as build artifacts
so that the repository does not carry hand-edited JSON blobs. Download the
latest run and unpack the language-specific directories under
`tests/fixtures/<language>/` before executing the red-phase client harnesses
locally:

| Language | Transport Fixtures |
| --- | --- |
| Python | `tests/fixtures/python/<transport>/{request,response}.json` (from workflow artifact) |
| Node.js | `tests/fixtures/node/<transport>/{request,response}.json` (from workflow artifact) |
| Go | `tests/fixtures/go/<transport>/{request,response}.json` (from workflow artifact) |

The baseline fixtures referenced by the roadmap are now committed to the
repository so contributors can diff new captures without waiting on the
automation uploads. Each transport has a matched request/response pair and a
golden conversation transcript:

| Language | Transport | Request Fixture | Response Fixture | Transcript |
| --- | --- | --- | --- | --- |
| Python | `stdio` | `tests/fixtures/python/stdio/request.json` | `tests/fixtures/python/stdio/response.json` | `tests/golden/python/stdio.transcript.json` |
| Python | `http` | `tests/fixtures/python/http/request.json` | `tests/fixtures/python/http/response.json` | `tests/golden/python/http.transcript.json` |
| Python | `tls` | `tests/fixtures/python/tls/request.json` | `tests/fixtures/python/tls/response.json` | `tests/golden/python/tls.transcript.json` |
| Node.js | `stdio` | `tests/fixtures/node/stdio/request.json` | `tests/fixtures/node/stdio/response.json` | `tests/golden/node/stdio.transcript.json` |
| Node.js | `http` | `tests/fixtures/node/http/request.json` | `tests/fixtures/node/http/response.json` | `tests/golden/node/http.transcript.json` |
| Node.js | `tls` | `tests/fixtures/node/tls/request.json` | `tests/fixtures/node/tls/response.json` | `tests/golden/node/tls.transcript.json` |
| Go | `stdio` | `tests/fixtures/go/stdio/request.json` | `tests/fixtures/go/stdio/response.json` | `tests/golden/go/stdio.transcript.json` |
| Go | `http` | `tests/fixtures/go/http/request.json` | `tests/fixtures/go/http/response.json` | `tests/golden/go/http.transcript.json` |
| Go | `tls` | `tests/fixtures/go/tls/request.json` | `tests/fixtures/go/tls/response.json` | `tests/golden/go/tls.transcript.json` |

Regenerate these artifacts by invoking the **Regenerate Fixture Corpus** and
**Regenerate Golden Artifacts** GitHub Actions described in the repository
[`README.md`](../../../README.md). The fixture workflow publishes refreshed
request/response envelopes, while the golden workflow normalizes and archives
the transcripts. When running the automation locally, mirror the workflow
sequence: capture raw exchanges, run
`python scripts/transcripts/normalize.py` to stabilize ordering, and update the
checksums before committing.

Each JSON file encodes the envelopes referenced in the roadmap so that early
test suites can validate CLI wiring and transcript diffing workflows. When
regenerating the fixtures, record the workflow URL, artifact checksum, and
normalization output per the [fixture management plan](../../testing/fixtures-plan.md).
Replace these placeholders with real captures once the clients can replay the
IDE transcripts listed in this directory, continuing to source them from the
automation rather than committing ad-hoc updates.
